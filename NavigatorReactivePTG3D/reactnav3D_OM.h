
#include <mrpt/obs/CObservation2DRangeScan.h>
#include <mrpt/maps/CSimplePointsMap.h>
#include <mrpt/maps/COccupancyGridMap2D.h>
#include <mrpt/utils/CRobotSimulator.h>
#include <mrpt/poses.h>
#include <mrpt/opengl.h>
#include <mrpt/gui/CDisplayWindow3D.h>
#include <mrpt/nav.h>
#include <COpenMORAMOOSApp.h>


class CRobotLevel {
public:
	float				m_height;
	std::vector <mrpt::math::TPoint2D>	m_points;
};


class CRobotKinects {
public:
	mrpt::maps::CSimplePointsMap	m_points;
	float				m_xrel;
	float				m_yrel;
	float				m_zrel;
	float				m_phi;
	int					m_level;
	float				m_min_range;
	float				m_max_range;
	float				m_fov_v;
	float				m_fov_h;
	float				m_pitch_angle;
	unsigned int		m_rows;
	unsigned int		m_columns;
	float				m_std_error;
	void CorrectFloorPoints(mrpt::poses::CPose3D kinectrelpose);
	void CorrectCeiling(mrpt::poses::CPose3D kinectrelpose, float height);
	void CorrectRanges(mrpt::poses::CPose3D kinectrelpose);
	void KinectScan(std::vector <mrpt::maps::COccupancyGridMap2D> m_maps,
					std::vector <CRobotLevel> m_levels,
					mrpt::poses::CPose3D robotpose,
					mrpt::poses::CPose3D kinectpose);
};

class CRobotLasers {
public:
	mrpt::obs::CObservation2DRangeScan m_scan;
	int	m_level;
	int	m_segments;
};


class CRobot3D {
public:
	std::vector <CRobotLevel>	m_levels;
	std::vector <CRobotLasers>	m_lasers;
	std::vector <CRobotKinects>	m_kinects;
};


//The structure used for storing a movement generated by a holonomic-method
struct THolonomicMovement {
	mrpt::nav::CParameterizedTrajectoryGenerator	*PTG;	// The associated PTG
	double	direction, speed;					// The holonomic movement
	double	evaluation;							// An evaluation in the range [0,1] for the goodness of the movement.
};


class CPTGmultilevel{
public:
	std::vector <mrpt::nav::CParameterizedTrajectoryGenerator*> PTGs;
	std::vector<float>		TPObstacles;
	mrpt::math::TPoint2D	TP_Target;
	THolonomicMovement		holonomicmov;
};


class CDynfeatures{
public:
	float   refDistance;					// "dmax" in papers.
	mrpt::poses::CPose2D pos_ini;			// Initial pose
	mrpt::poses::CPose2D curposeodo;		// Updated odometry pose
	mrpt::poses::CPose2D curpose;			// Updated pose
	float   robotMax_V_mps;					// Robot max. speed in m/s
	float   robotMax_W_degps;				// Robot max. angular speed in rad/s
	float	ROBOTMODEL_TAU;					// Param for the motor system modelation
	float	ROBOTMODEL_DELAY;				// Param for the motor system modelation
	float	last_cmd_v;
	float	last_cmd_w;
	float	new_cmd_v;
	float	new_cmd_w;
};

class CReactiveparam{
public:
	bool					m_holonomicmethod;
	std::vector<float>		weights;				// length: 6 [0,5]
	mrpt::poses::CPoint2D	WS_Target;
	mrpt::poses::CPoint2D	rel_Target;
	THolonomicMovement		m_movselected;
	unsigned int			m_ptgselected;
	bool					m_reload_ptgfiles;
	bool					m_recordLogFile;
};

enum Navigation_State {PAUSED = 0, CANCELLED, ACTIVE, WAITING};


class CReactiveNavigator {
public:
	Navigation_State				m_navstate;
	CRobot3D						m_robot;
	CDynfeatures					m_dynfeatures;
	CReactiveparam					m_reactiveparam;
	std::vector <mrpt::maps::COccupancyGridMap2D>	m_maps;
	mrpt::utils::CRobotSimulator	m_robmov;
	mrpt::gui::CDisplayWindow3DPtr	m_window;
	mrpt::opengl::COpenGLScenePtr	m_scene;
	std::vector <CPTGmultilevel>	m_ptgmultilevel;
	mrpt::utils::CStream			*m_logFile;
	std::vector <mrpt::maps::CSimplePointsMap>	m_obstacles_inlevels;
	std::vector <mrpt::nav::CHolonomicLogFileRecordPtr> m_HLFRs;
	mrpt::nav::CLogFileRecord				m_newLogRec;
	mrpt::nav::CHolonomicVFF				*m_holonomicVFF;
	std::vector <mrpt::nav::CHolonomicND*>	m_holonomicND;

	//Load the robot configuration: shape, lasers, kinects and dynamical parameters
	void loadRobotConfiguration(CMissionReader2ConfigFile_adaptor configRobot);

	//Load the family of maps indicated, and the desired number of maps belonging to this family at a given resolution
	void loadMapsfromimages(CMissionReader2ConfigFile_adaptor configRobot);

	//Initialize the kinematical and dynamical parameters of the robot motion
	void InitializeRobotMotion();

	//Move the robot according to the new commands obtained from PTGs
	void SimulateRobotMotion(float dt);

	//Simulate a scan of every sensors
	void SimulateSensors();

	//Initialize the simulator 3D scene
	void InitializeScene();

	//Update the 3D scene with the new robot pose and sensor measurements
	void ShowRobotMotion();

	//Sort the points (obstacles) detected by sensors in the different height levels of the robot
	void ClassifyPointsInLevels();

	//Transform detected points (already sorted) into TP-Obstacles in the TP-Space
	void ObstaclesToTPSpace();

	//Read parameters of each PTG, and generate N x L collision grids taking into account the shape of the robot,
	//being "N" the number of PTGs and "L" the number of height levels
	void PTGGridBuilder(CMissionReader2ConfigFile_adaptor configRobot);

	//Select the best "alfa" for each PTG according to the selected holonomic method and the TP-Obstacles
	void ApplyHolonomicMethod();

	//Evaluate the best option of each PTG
	void EvaluateAllPTGs();

	//Select the best option of all of them
	void PTG_Selector();

	//Obtain linear and angular speed commands from the chosen PTG and "alpha"
	void GenerateSpeedCommands();

	//Save data of una iteration of the reactive loop
	void SaveInLogFile( mrpt::utils::CStream *logFile );

	//Auxiliary function that builds the collision grid for one PTG
	void build_PTG_collision_grids(
	mrpt::nav::CParameterizedTrajectoryGenerator * PT,
	const mrpt::math::CPolygon        & robotShape,
	const std::string                 & cacheFilename,
	const bool                          verbose
	);

	//Auxiliary function that evaluates the best solution (alpha) of one PTG
	void PTG_Evaluator(
		THolonomicMovement				&in_holonomicMovement,
		std::vector<float>				&in_TPObstacles,
		const mrpt::poses::CPoint2D		&rel_Target,
		const mrpt::poses::CPoint2D		&TP_Target,
		mrpt::nav::CLogFileRecord::TInfoPerPTG	&log);

	//Auxiliary function that sets up the log file recording
	void EnableLogFile(mrpt::utils::CStream *&LogFile);

	//CReactiveNavigator (CMissionReader2ConfigFile_adaptor configRobot):m_holonomicVFF(configRobot), m_holonomicND(configRobot) {};
	//~CReactiveNavigator ();
};

