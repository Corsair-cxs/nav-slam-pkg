
#include <mrpt/slam/CObservation2DRangeScan.h>
#include <mrpt/slam/CSimplePointsMap.h>
#include <mrpt/slam/COccupancyGridMap2D.h>
#include <mrpt/utils/CRobotSimulator.h>
#include <mrpt/poses/CPoint2D.h>
#include <mrpt/opengl.h>
#include <mrpt/gui/CDisplayWindow3D.h>
#include <mrpt/reactivenav.h>
#include <mrpt/nav.h>
#include <COpenMORAMOOSApp.h>

using namespace mrpt;
using namespace mrpt::gui;
using namespace mrpt::opengl;
using namespace mrpt::math;
using namespace mrpt::utils;
using namespace mrpt::slam;
using namespace mrpt::reactivenav;
using namespace std;


class CRobotLevel {
public:
	float				m_height;
	vector <TPoint2D>	m_points;
};


class CRobotKinects {
public:
	CSimplePointsMap	m_points;
	float				m_xrel;
	float				m_yrel;
	float				m_zrel;
	float				m_phi;
	int					m_level;
	float				m_min_range;
	float				m_max_range;
	float				m_fov_v;
	float				m_fov_h;
	float				m_pitch_angle;
	unsigned int		m_rows;
	unsigned int		m_columns;
	float				m_std_error;
	void CorrectFloorPoints(CPose3D kinectrelpose);
	void CorrectCeiling(CPose3D kinectrelpose, float height);
	void CorrectRanges(CPose3D kinectrelpose);
	void KinectScan(vector <COccupancyGridMap2D> m_maps, vector <CRobotLevel> m_levels, CPose3D robotpose,CPose3D kinectpose);
};

class CRobotLasers {
public:
	CObservation2DRangeScan m_scan;
	int						m_level;
	int						m_segments;
};


class CRobot3D {
public:
	vector <CRobotLevel>	m_levels;
	vector <CRobotLasers>	m_lasers;
	vector <CRobotKinects>	m_kinects;
};


//The structure used for storing a movement generated by a holonomic-method
struct THolonomicMovement {
	CParameterizedTrajectoryGenerator	*PTG;	// The associated PTG
	double	direction, speed;					// The holonomic movement
	double	evaluation;							// An evaluation in the range [0,1] for the goodness of the movement.
};


class CPTGmultilevel{
public:
	vector <CParameterizedTrajectoryGenerator*> PTGs;
	std::vector<float>							TPObstacles;
	TPoint2D									TP_Target;
	THolonomicMovement							holonomicmov;
};


class CDynfeatures{
public:
	float   refDistance;					// "dmax" in papers.
	CPose2D pos_ini;						// Initial pose
	CPose2D curposeodo;						// Updated odometry pose
	CPose2D curpose;						// Updated pose
	float   robotMax_V_mps;					// Robot max. speed in m/s
	float   robotMax_W_degps;				// Robot max. angular speed in rad/s
	float	ROBOTMODEL_TAU;					// Param for the motor system modelation
	float	ROBOTMODEL_DELAY;				// Param for the motor system modelation
	float	last_cmd_v;
	float	last_cmd_w;
	float	new_cmd_v;
	float	new_cmd_w;
};

class CReactiveparam{
public:
	bool				m_holonomicmethod;
	std::vector<float>	weights;				// length: 6 [0,5]
	CPoint2D			WS_Target;
	CPoint2D			rel_Target;
	THolonomicMovement	m_movselected;
	unsigned int		m_ptgselected;
	bool				m_reload_ptgfiles;
	bool				m_recordLogFile;
};

enum Navigation_State {PAUSED = 0, CANCELLED, ACTIVE, WAITING};


class CReactiveNavigator {
public:
	Navigation_State				m_navstate;
	CRobot3D						m_robot;
	CDynfeatures					m_dynfeatures;
	CReactiveparam					m_reactiveparam;
	vector <COccupancyGridMap2D>	m_maps;
	CRobotSimulator					m_robmov;
	CDisplayWindow3DPtr				m_window;
	COpenGLScenePtr					m_scene;
	vector <CSimplePointsMap>		m_obstacles_inlevels;
	vector <CPTGmultilevel>			m_ptgmultilevel;
	CStream							*m_logFile;
	vector <CHolonomicLogFileRecordPtr> m_HLFRs;
	CLogFileRecord					m_newLogRec;
	CHolonomicVFF					*m_holonomicVFF;
	vector <CHolonomicND*>			m_holonomicND;

	//Load the robot configuration: shape, lasers, kinects and dynamical parameters
	void loadRobotConfiguration(CMissionReader2ConfigFile_adaptor configRobot);

	//Load the family of maps indicated, and the desired number of maps belonging to this family at a given resolution
	void loadMapsfromimages(CMissionReader2ConfigFile_adaptor configRobot);

	//Initialize the kinematical and dynamical parameters of the robot motion
	void InitializeRobotMotion();

	//Move the robot according to the new commands obtained from PTGs
	void SimulateRobotMotion(float dt);

	//Simulate a scan of every sensors
	void SimulateSensors();

	//Initialize the simulator 3D scene
	void InitializeScene();

	//Update the 3D scene with the new robot pose and sensor measurements
	void ShowRobotMotion();

	//Sort the points (obstacles) detected by sensors in the different height levels of the robot
	void ClassifyPointsInLevels();

	//Transform detected points (already sorted) into TP-Obstacles in the TP-Space
	void ObstaclesToTPSpace();

	//Read parameters of each PTG, and generate N x L collision grids taking into account the shape of the robot,
	//being "N" the number of PTGs and "L" the number of height levels
	void PTGGridBuilder(CMissionReader2ConfigFile_adaptor configRobot);

	//Select the best "alfa" for each PTG according to the selected holonomic method and the TP-Obstacles
	void ApplyHolonomicMethod();

	//Evaluate the best option of each PTG
	void EvaluateAllPTGs();

	//Select the best option of all of them
	void PTG_Selector();

	//Obtain linear and angular speed commands from the chosen PTG and "alpha"
	void GenerateSpeedCommands();

	//Save data of una iteration of the reactive loop
	void SaveInLogFile( CStream *logFile );

	//Auxiliary function that builds the collision grid for one PTG
	void build_PTG_collision_grids(
	CParameterizedTrajectoryGenerator * PT,
	const mrpt::math::CPolygon        & robotShape,
	const std::string                 & cacheFilename,
	const bool                          verbose
	);

	//Auxiliary function that evaluates the best solution (alpha) of one PTG
	void PTG_Evaluator(
		THolonomicMovement				&in_holonomicMovement,
		std::vector<float>				&in_TPObstacles,
		const mrpt::poses::CPoint2D		&rel_Target,
		const mrpt::poses::CPoint2D		&TP_Target,
		CLogFileRecord::TInfoPerPTG	&log);

	//Auxiliary function that sets up the log file recording
	void EnableLogFile(CStream *&LogFile);

	//CReactiveNavigator (CMissionReader2ConfigFile_adaptor configRobot):m_holonomicVFF(configRobot), m_holonomicND(configRobot) {};
	//~CReactiveNavigator ();
};

